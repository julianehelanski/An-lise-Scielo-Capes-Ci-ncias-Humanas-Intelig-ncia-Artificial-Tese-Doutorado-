# -*- coding: utf-8 -*-
"""
Created on Mon Nov 10 18:04:17 2025

@author: julia
"""

"""
================================================================================
AN√ÅLISE COMPLETA - CAT√ÅLOGO DE TESES CAPES SOBRE INTELIG√äNCIA ARTIFICIAL
================================================================================

VERS√ÉO 4.12 - CORRIGIDA (Bugs Resolvidos)

PRINCIPAIS CORRE√á√ïES:
- Tratamento robusto de dados ausentes em colunas cr√≠ticas
- Verifica√ß√£o de colunas antes de processamento
- Gest√£o adequada de tipos de dados
- Tratamento de erros em visualiza√ß√µes

INSTRU√á√ïES DE USO:
1. Coloque os arquivos de dados na mesma pasta
2. Execute: python analise_capes_ia_corrigido.py
3. Os gr√°ficos ser√£o salvos na pasta 'graficos/' e exibidos na tela.

REQUISITOS:
pip install pandas numpy matplotlib seaborn openpyxl

================================================================================
"""

# =============================================================================
# IMPORTA√á√ïES
# =============================================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import warnings
from collections import Counter
from matplotlib import cm

warnings.filterwarnings('ignore')

# =============================================================================
# CONFIGURA√á√ïES DE VISUALIZA√á√ÉO
# =============================================================================
plt.style.use('default')
sns.set_style("whitegrid")

# Configura√ß√µes gerais
plt.rcParams['figure.figsize'] = (14, 8)
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['savefig.facecolor'] = 'white'
plt.rcParams['savefig.edgecolor'] = 'none'
plt.rcParams['figure.dpi'] = 100
plt.rcParams['savefig.dpi'] = 300
plt.rcParams['font.size'] = 10
plt.rcParams['axes.titlesize'] = 13
plt.rcParams['axes.labelsize'] = 11
plt.rcParams['axes.titleweight'] = 'bold'

# Paleta de cores INTERMEDI√ÅRIAS
CORES_INTERMEDIARIAS = [
    '#E57373',  # 0: Muted Red
    '#FFB74D',  # 1: Muted Orange
    '#81C784',  # 2: Muted Green
    '#64B5F6',  # 3: Muted Blue
    '#BA68C8',  # 4: Muted Purple
    '#FFF176',  # 5: Muted Yellow
    '#F06292',  # 6: Muted Pink
    '#4DB6AC',  # 7: Muted Teal
    '#A1887F',  # 8: Muted Brown
    '#90A4AE',  # 9: Muted Blue-Gray
    '#B0BEC5',  # 10: Light Muted Gray
    '#E0E0E0',  # 11: Very Light Gray
]

# Cores espec√≠ficas
COR_AZUL_PRINCIPAL = CORES_INTERMEDIARIAS[3]
COR_MESTRADO = CORES_INTERMEDIARIAS[3]
COR_DOUTORADO = CORES_INTERMEDIARIAS[1]
COR_MEDIANA = CORES_INTERMEDIARIAS[0]
COR_IA_CENTRAL = CORES_INTERMEDIARIAS[0]
COR_IA_RELACIONADA = CORES_INTERMEDIARIAS[1]
COR_IA_OUTROS = CORES_INTERMEDIARIAS[3]
CORES_TOP3 = [CORES_INTERMEDIARIAS[0], CORES_INTERMEDIARIAS[1], CORES_INTERMEDIARIAS[2]]

def gerar_paleta_expandida(n):
    """Gera uma paleta de cores intermedi√°rias harmoniosas para n itens"""
    if n <= len(CORES_INTERMEDIARIAS):
        return CORES_INTERMEDIARIAS[:n]
    
    paleta = CORES_INTERMEDIARIAS.copy()
    cores_extras = sns.color_palette("tab10", n - len(paleta))
    
    def mute_color(rgb_tuple):
        r, g, b = [int(c * 255) for c in rgb_tuple]
        r_muted = (r + 224) // 2 
        g_muted = (g + 224) // 2
        b_muted = (b + 224) // 2
        return '#{:02x}{:02x}{:02x}'.format(r_muted, g_muted, b_muted)

    for cor in cores_extras:
        paleta.append(mute_color(cor))
    
    return paleta[:n]

print("="*80)
print("AN√ÅLISE DO CAT√ÅLOGO DE TESES CAPES - INTELIG√äNCIA ARTIFICIAL")
print("="*80)
print("\nVERS√ÉO 4.12 - CORRIGIDA")
print("="*80)

# =============================================================================
# 1. CARREGAR DADOS
# =============================================================================
print("\n[1/10] Carregando dados...")

# Verificar qual arquivo est√° dispon√≠vel
arquivo_dados = None
arquivos_possiveis = [
    'catalogo_teses_analise.xlsx',
    'catalogo_teses_analise__2_.xlsx',
    'catalogo_teses_limpo__2_.csv',
    'catalogodeteses__4_.csv'
]

for arquivo in arquivos_possiveis:
    if os.path.exists(arquivo):
        arquivo_dados = arquivo
        break

if arquivo_dados is None:
    print("\n‚ùå ERRO: Nenhum arquivo de dados encontrado!")
    print("   Arquivos esperados:", arquivos_possiveis)
    exit()

# Carregar dados
try:
    if arquivo_dados.endswith('.xlsx'):
        df = pd.read_excel(arquivo_dados, sheet_name='Dados Completos')
    else:
        df = pd.read_csv(arquivo_dados)
    print(f"‚úì Arquivo carregado: {arquivo_dados}")
except Exception as e:
    print(f"‚ùå ERRO ao carregar arquivo: {e}")
    exit()

# Verificar colunas necess√°rias
colunas_necessarias = ['titulo', 'autor', 'ano_defesa', 'nivel', 'area', 'instituicao']
colunas_faltantes = [col for col in colunas_necessarias if col not in df.columns]

if colunas_faltantes:
    print(f"\n‚ùå ERRO: Colunas faltantes no dataset: {colunas_faltantes}")
    print(f"   Colunas dispon√≠veis: {list(df.columns)}")
    exit()

# Limpeza inicial
if 'id' in df.columns:
    df = df[df['id'] != 'col-md-1'].copy()

df = df[df['titulo'].notna()].copy()
df = df[df['autor'].notna()].copy()

# Normaliza√ß√£o
df['area_normalizada'] = df['area'].fillna('N√ÉO ESPECIFICADA').str.upper().str.strip()
df['ano_defesa'] = pd.to_numeric(df['ano_defesa'], errors='coerce')
df = df[df['ano_defesa'].notna()].copy()  # Remover registros sem ano
df['ano_defesa'] = df['ano_defesa'].astype(int)
df['decada'] = (df['ano_defesa'] // 10 * 10)

# Tratar cidade se existir
if 'cidade' in df.columns:
    df['cidade'] = df['cidade'].fillna('N√ÉO ESPECIFICADA')
else:
    df['cidade'] = 'N√ÉO ESPECIFICADA'

# Tratar p√°ginas se existir
if 'num_paginas' in df.columns:
    df['num_paginas'] = pd.to_numeric(df['num_paginas'], errors='coerce')
else:
    df['num_paginas'] = np.nan

print(f"‚úì {len(df)} publica√ß√µes carregadas")
print(f"‚úì Per√≠odo: {df['ano_defesa'].min()}-{df['ano_defesa'].max()}")

# =============================================================================
# 2. CLASSIFICA√á√ÉO POR FOCO EM IA
# =============================================================================
print("\n[2/10] Classificando por foco em IA...")

keywords_ia_forte = [
    'intelig√™ncia artificial', 'ia ', 'artificial intelligence',
    'machine learning', 'deep learning', 'redes neurais', 'neural networks',
    'aprendizado de m√°quina', 'algoritmo', 'chatbot', 'gpt', 'llm'
]

keywords_ia_relacionada = [
    'transhumanismo', 'rob√≥tica', 'automa√ß√£o', 'digitaliza√ß√£o',
    'tecnologia digital', 'computacional', 'dados', 'big data',
    'internet', 'online', 'virtual', 'cibern√©tico'
]

def classificar_foco_ia(titulo):
    """Classifica o foco do trabalho em rela√ß√£o √† IA"""
    if pd.isna(titulo):
        return 'Outros Temas'
    
    titulo_lower = str(titulo).lower()
    
    for keyword in keywords_ia_forte:
        if keyword in titulo_lower:
            return 'IA - Foco Central'
    
    for keyword in keywords_ia_relacionada:
        if keyword in titulo_lower:
            return 'IA - Foco Relacionado'
    
    return 'Outros Temas'

df['foco_ia'] = df['titulo'].apply(classificar_foco_ia)
foco_counts = df['foco_ia'].value_counts()

print("‚úì Classifica√ß√£o conclu√≠da:")
for foco, count in foco_counts.items():
    print(f"  - {foco}: {count} ({count/len(df)*100:.1f}%)")

# =============================================================================
# 3. AN√ÅLISE TEMPORAL
# =============================================================================
print("\n[3/10] Analisando tend√™ncias temporais...")

pub_por_ano = df.groupby('ano_defesa').size().reset_index(name='quantidade')
pub_por_ano = pub_por_ano.sort_values('ano_defesa')

anos_recentes = pub_por_ano[pub_por_ano['ano_defesa'] >= 2020]['quantidade'].sum()

if len(pub_por_ano) > 1:
    crescimento = ((pub_por_ano.iloc[-1]['quantidade'] - pub_por_ano.iloc[0]['quantidade']) / 
                   pub_por_ano.iloc[0]['quantidade'] * 100)
    print(f"‚úì Crescimento: {crescimento:.0f}% ({pub_por_ano.iloc[0]['ano_defesa']}‚Üí{pub_por_ano.iloc[-1]['ano_defesa']})")
else:
    crescimento = 0
    print("‚úì Dados insuficientes para calcular crescimento")

print(f"‚úì √öltimos 3 anos: {anos_recentes} publica√ß√µes ({anos_recentes/len(df)*100:.1f}%)")

# =============================================================================
# 4. AN√ÅLISE POR N√çVEL
# =============================================================================
print("\n[4/10] Analisando n√≠vel acad√™mico...")

nivel_counts = df['nivel'].value_counts()
nivel_ano = df.groupby(['ano_defesa', 'nivel']).size().unstack(fill_value=0)

print(f"‚úì Mestrados: {nivel_counts.get('Mestrado', 0)} ({nivel_counts.get('Mestrado', 0)/len(df)*100:.1f}%)")
print(f"‚úì Doutorados: {nivel_counts.get('Doutorado', 0)} ({nivel_counts.get('Doutorado', 0)/len(df)*100:.1f}%)")

# =============================================================================
# 5. AN√ÅLISE DE √ÅREAS (TODAS)
# =============================================================================
print("\n[5/10] Analisando todas as √°reas tem√°ticas...")

area_counts = df['area_normalizada'].value_counts()
areas_freq_maior_1 = area_counts[area_counts > 1].sort_values(ascending=False) 
areas_freq_1 = area_counts[area_counts == 1]

print(f"‚úì Total de √°reas: {len(area_counts)}")
print(f"‚úì √Åreas com 2+ publica√ß√µes: {len(areas_freq_maior_1)}")
print(f"‚úì √Åreas com 1 publica√ß√£o: {len(areas_freq_1)}")
if len(area_counts) >= 3:
    print(f"‚úì Top 3 √°reas:")
    for i, (area, count) in enumerate(area_counts.head(3).items(), 1):
        print(f"  {i}. {area}: {count} ({count/len(df)*100:.1f}%)")

# =============================================================================
# 6. AN√ÅLISE DE INSTITUI√á√ïES (TODAS)
# =============================================================================
print("\n[6/10] Analisando todas as institui√ß√µes...")

inst_counts = df['instituicao'].value_counts()
inst_freq_maior_1 = inst_counts[inst_counts > 1].sort_values(ascending=False)
inst_freq_1 = inst_counts[inst_counts == 1]

print(f"‚úì Total de institui√ß√µes: {len(inst_counts)}")
print(f"‚úì Institui√ß√µes com 2+ publica√ß√µes: {len(inst_freq_maior_1)}")
print(f"‚úì Institui√ß√µes com 1 publica√ß√£o: {len(inst_freq_1)}")
if len(inst_counts) >= 3:
    print(f"‚úì Top 3 institui√ß√µes:")
    for i, (inst, count) in enumerate(inst_counts.head(3).items(), 1):
        print(f"  {i}. {inst}: {count} ({count/len(df)*100:.1f}%)")

# =============================================================================
# 7. AN√ÅLISE DE CIDADES
# =============================================================================
print("\n[7/10] Analisando distribui√ß√£o por cidades...")

cidade_counts = df['cidade'].value_counts()
print("‚úì Top 5 cidades:")
for i, (cidade, count) in enumerate(cidade_counts.head(5).items(), 1):
    print(f"  {i}. {cidade}: {count} ({count/len(df)*100:.1f}%)")

# =============================================================================
# 8. AN√ÅLISE DE TERMOS FREQUENTES
# =============================================================================
print("\n[8/10] Extraindo termos mais frequentes...")

def extrair_termos(texto):
    """Extrai termos relevantes do texto"""
    if pd.isna(texto):
        return []
    
    palavras = str(texto).lower().split()
    stopwords = {'de', 'da', 'do', 'dos', 'das', 'e', 'o', 'a', 'os', 'as', 
                 'em', 'no', 'na', 'nos', 'nas', 'para', 'com', 'por', 'um', 'uma'}
    
    termos = [p for p in palavras if len(p) > 4 and p not in stopwords]
    return termos

todos_termos = []
for titulo in df['titulo'].dropna():
    todos_termos.extend(extrair_termos(titulo))

termo_freq = Counter(todos_termos)
top_termos = termo_freq.most_common(20)

if top_termos:
    print(f"‚úì Top 5 termos: {', '.join([t[0] for t in top_termos[:5]])}")

# =============================================================================
# 9. AN√ÅLISE DE P√ÅGINAS
# =============================================================================
print("\n[9/10] Analisando n√∫mero de p√°ginas...")

if df['num_paginas'].notna().sum() > 0:
    paginas_stats = df['num_paginas'].describe()
    print(f"‚úì M√©dia: {paginas_stats['mean']:.0f} p√°ginas")
    print(f"‚úì Mediana: {paginas_stats['50%']:.0f} p√°ginas")
else:
    print("‚úì Dados de p√°ginas n√£o dispon√≠veis")

# =============================================================================
# 10. CRIAR PASTA PARA GR√ÅFICOS
# =============================================================================
print("\n[10/10] Preparando gera√ß√£o de gr√°ficos...")

if not os.path.exists('graficos'):
    os.makedirs('graficos')
    print("‚úì Pasta 'graficos/' criada")

# =============================================================================
# 11. GERAR GR√ÅFICOS
# =============================================================================
print("\n" + "="*80)
print("GERANDO GR√ÅFICOS COM CORES INTERMEDI√ÅRIAS E GRADIENTES")
print("="*80)

# GR√ÅFICO 1: Evolu√ß√£o Temporal - 4 VERS√ïES PADRONIZADAS
print("\nüìä Gr√°fico 1/9: Evolu√ß√£o Temporal das Publica√ß√µes (4 vers√µes)")

# CORES ROXO PARA CAPES
COR_ROXO_PRINCIPAL = '#9C27B0'  # Roxo m√©dio
COR_ROXO_ESCURO = '#6A1B9A'     # Roxo escuro
COR_ROXO_CLARO = '#BA68C8'      # Roxo claro

try:
    # ===== VERS√ÉO 1: BARRAS - SIMPLES =====
    fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')
    
    bars = ax.bar(pub_por_ano['ano_defesa'], pub_por_ano['quantidade'],
                  color=COR_ROXO_PRINCIPAL, edgecolor='black', linewidth=1.5, alpha=0.85)
    
    for bar, row in zip(bars, pub_por_ano.itertuples()):
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height(),
                f'{int(row.quantidade)}', ha='center', va='bottom', 
                fontweight='bold', fontsize=9)
    
    ax.set_title(f'Distribui√ß√£o Temporal das Publica√ß√µes - CAPES (Barras Simples)',
                 fontweight='bold', fontsize=13, pad=20)
    ax.set_xlabel('Ano de Defesa', fontsize=12)
    ax.set_ylabel('Quantidade de Publica√ß√µes', fontsize=12)
    ax.set_facecolor('white')
    ax.grid(True, alpha=0.3, axis='y', linestyle='--')
    ax.set_axisbelow(True)

    plt.tight_layout()
    plt.savefig('graficos/01a_temporal_barras_simples.png', dpi=300, bbox_inches='tight', facecolor='white')
    plt.show()
    print("‚úì Vers√£o 1 (Barras Simples) gerada com sucesso")
    
    # ===== VERS√ÉO 2: BARRAS - COM DESTAQUE =====
    fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')
    
    bars = ax.bar(pub_por_ano['ano_defesa'], pub_por_ano['quantidade'],
                  color=COR_ROXO_CLARO, edgecolor='black', linewidth=1.5, alpha=0.85)
    
    # Destacar ano com mais publica√ß√µes
    max_idx = pub_por_ano['quantidade'].idxmax()
    bars[max_idx].set_color(COR_ROXO_ESCURO)
    bars[max_idx].set_linewidth(2.5)
    bars[max_idx].set_alpha(1.0)
    
    for bar, row in zip(bars, pub_por_ano.itertuples()):
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height(),
                f'{int(row.quantidade)}', ha='center', va='bottom', 
                fontweight='bold', fontsize=9)
    
    ax.set_title(f'Distribui√ß√£o Temporal das Publica√ß√µes - CAPES (Barras com Destaque)',
                 fontweight='bold', fontsize=13, pad=20)
    ax.set_xlabel('Ano de Defesa', fontsize=12)
    ax.set_ylabel('Quantidade de Publica√ß√µes', fontsize=12)
    ax.set_facecolor('white')
    ax.grid(True, alpha=0.3, axis='y', linestyle='--')
    ax.set_axisbelow(True)

    plt.tight_layout()
    plt.savefig('graficos/01b_temporal_barras_destaque.png', dpi=300, bbox_inches='tight', facecolor='white')
    plt.show()
    print("‚úì Vers√£o 2 (Barras Destaque) gerada com sucesso")
    
    # ===== VERS√ÉO 3: LINHA - SIMPLES =====
    fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')
    
    ax.plot(pub_por_ano['ano_defesa'], pub_por_ano['quantidade'], 
            marker='o', linewidth=3, markersize=8, 
            color=COR_ROXO_PRINCIPAL, markerfacecolor=COR_ROXO_ESCURO,
            markeredgecolor='black', markeredgewidth=1.5)

    for i, row in pub_por_ano.iterrows():
        ax.text(row['ano_defesa'], row['quantidade'] + pub_por_ano['quantidade'].max()*0.02, 
                str(int(row['quantidade'])), ha='center', va='bottom', 
                fontweight='bold', fontsize=9)

    ax.set_title(f'Distribui√ß√£o Temporal das Publica√ß√µes - CAPES (Linha Simples)',
                 fontweight='bold', fontsize=13, pad=20)
    ax.set_xlabel('Ano de Defesa', fontsize=12)
    ax.set_ylabel('Quantidade de Publica√ß√µes', fontsize=12)
    ax.set_facecolor('white')
    ax.grid(True, alpha=0.3, linestyle='--')

    plt.tight_layout()
    plt.savefig('graficos/01c_temporal_linha_simples.png', dpi=300, bbox_inches='tight', facecolor='white')
    plt.show()
    print("‚úì Vers√£o 3 (Linha Simples) gerada com sucesso")
    
    # ===== VERS√ÉO 4: LINHA - COM √ÅREA PREENCHIDA =====
    fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')
    
    ax.plot(pub_por_ano['ano_defesa'], pub_por_ano['quantidade'], 
            marker='o', linewidth=3, markersize=8, 
            color=COR_ROXO_ESCURO, markerfacecolor=COR_ROXO_PRINCIPAL,
            markeredgecolor='black', markeredgewidth=1.5, label='Publica√ß√µes')
    
    ax.fill_between(pub_por_ano['ano_defesa'], pub_por_ano['quantidade'], 
                    alpha=0.3, color=COR_ROXO_PRINCIPAL)

    for i, row in pub_por_ano.iterrows():
        ax.text(row['ano_defesa'], row['quantidade'] + pub_por_ano['quantidade'].max()*0.02, 
                str(int(row['quantidade'])), ha='center', va='bottom', 
                fontweight='bold', fontsize=9)

    ax.set_title(f'Distribui√ß√£o Temporal das Publica√ß√µes - CAPES (Linha com √Årea)',
                 fontweight='bold', fontsize=13, pad=20)
    ax.set_xlabel('Ano de Defesa', fontsize=12)
    ax.set_ylabel('Quantidade de Publica√ß√µes', fontsize=12)
    ax.set_facecolor('white')
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.legend(fontsize=11, loc='upper left')

    plt.tight_layout()
    plt.savefig('graficos/01d_temporal_linha_area.png', dpi=300, bbox_inches='tight', facecolor='white')
    plt.show()
    print("‚úì Vers√£o 4 (Linha com √Årea) gerada com sucesso")
    
    print("‚úì 4 vers√µes de Evolu√ß√£o Temporal geradas com sucesso")
    
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 1: {e}")

# GR√ÅFICO 2: Distribui√ß√£o por N√≠vel
print("\nüìä Gr√°fico 2/9: Distribui√ß√£o por N√≠vel Acad√™mico")
try:
    fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')

    nivel_counts_sorted = nivel_counts.sort_values(ascending=False)
    colors = [COR_MESTRADO, COR_DOUTORADO]
    bars = ax.bar(range(len(nivel_counts_sorted)), nivel_counts_sorted.values,
                  color=colors[:len(nivel_counts_sorted)], edgecolor='black', linewidth=1.5)

    ax.set_xticks(range(len(nivel_counts_sorted)))
    ax.set_xticklabels(nivel_counts_sorted.index, fontsize=11)
    ax.set_title(f'Distribui√ß√£o por n√≠vel acad√™mico',
                 fontweight='bold', fontsize=13, pad=20)
    ax.set_ylabel('Quantidade', fontsize=12)
    ax.set_facecolor('white')
    ax.grid(True, alpha=0.3, axis='y', linestyle='--')

    for bar, v in zip(bars, nivel_counts_sorted.values):
        pct = (v/len(df))*100
        ax.text(bar.get_x() + bar.get_width()/2, v + 1, 
                f'{v}\n({pct:.1f}%)', ha='center', fontweight='bold', fontsize=10)

    plt.tight_layout()
    plt.savefig('graficos/02_nivel_academico.png', dpi=300, bbox_inches='tight', facecolor='white')
    plt.show()
    print("‚úì Gr√°fico 2 gerado com sucesso")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 2: {e}")

# GR√ÅFICO 3: TODAS AS √ÅREAS TEM√ÅTICAS
print("\nüìä Gr√°fico 3/9: Todas as √Åreas Tem√°ticas (Frequ√™ncia > 1)")
try:
    if len(areas_freq_maior_1) > 0:
        fig, ax = plt.subplots(figsize=(14, max(10, len(areas_freq_maior_1) * 0.4)), facecolor='white')

        areas_display = areas_freq_maior_1.copy()
        N = len(areas_display)
        cmap = cm.get_cmap('Purples_r', N + 5)
        cores = [cmap(i) for i in range(N)]

        bars = ax.barh(range(N), areas_display.values,
                       color=cores, edgecolor='black', linewidth=1.2)

        ax.set_yticks(range(N))
        ax.set_yticklabels(areas_display.index, fontsize=9)
        ax.invert_yaxis()

        ax.set_title(f'Distribui√ß√£o por √°reas tem√°ticas',
                     fontweight='bold', fontsize=13, pad=20)
        ax.set_xlabel('Quantidade de Publica√ß√µes', fontsize=11)
        ax.set_facecolor('white')
        ax.grid(True, alpha=0.3, axis='x', linestyle='--')

        for bar, v in zip(bars, areas_display.values):
            pct = (v/len(df))*100
            ax.text(v + 0.2, bar.get_y() + bar.get_height()/2,
                    f'{int(v)} ({pct:.1f}%)', va='center', fontsize=8, fontweight='bold')

        if len(areas_freq_1) > 0:
            areas_outras_lista = ', '.join(areas_freq_1.index[:10])
            if len(areas_freq_1) > 10:
                areas_outras_lista += f', ... (mais {len(areas_freq_1) - 10})'
            
            fig.text(0.12, 0.02, f'* √Åreas com 1 publica√ß√£o (total {len(areas_freq_1)}) incluem: {areas_outras_lista}',
                     fontsize=8, style='italic', wrap=True,
                     bbox=dict(boxstyle='round', facecolor=CORES_INTERMEDIARIAS[5], alpha=0.6))

        plt.tight_layout()
        plt.subplots_adjust(bottom=0.08)
        plt.savefig('graficos/03_todas_areas.png', dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()
        print("‚úì Gr√°fico 3 gerado com sucesso")
    else:
        print("‚ö† Sem dados suficientes para gr√°fico de √°reas")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 3: {e}")

# GR√ÅFICO 4: TODAS AS INSTITUI√á√ïES
print("\nüìä Gr√°fico 4/9: Todas as Institui√ß√µes (Frequ√™ncia > 1)")
try:
    if len(inst_freq_maior_1) > 0:
        fig, ax = plt.subplots(figsize=(14, max(10, len(inst_freq_maior_1) * 0.4)), facecolor='white')

        inst_display = inst_freq_maior_1.copy()
        N = len(inst_display)
        cmap = cm.get_cmap('Blues_r', N + 5)
        cores_inst = [cmap(i) for i in range(N)]

        bars = ax.barh(range(N), inst_display.values,
                       color=cores_inst, edgecolor='black', linewidth=1.2)

        ax.set_yticks(range(N))
        ax.set_yticklabels(inst_display.index, fontsize=9)
        ax.invert_yaxis()

        ax.set_title(f'Distribui√ß√£o por institui√ß√µes',
                     fontweight='bold', fontsize=13, pad=20)
        ax.set_xlabel('Quantidade de Publica√ß√µes', fontsize=11)
        ax.set_facecolor('white')
        ax.grid(True, alpha=0.3, axis='x', linestyle='--')

        for bar, v in zip(bars, inst_display.values):
            pct = (v/len(df))*100
            ax.text(v + 0.15, bar.get_y() + bar.get_height()/2,
                    f'{int(v)} ({pct:.1f}%)', va='center', fontsize=8, fontweight='bold')

        if len(inst_freq_1) > 0:
            inst_outras_lista = ', '.join(inst_freq_1.index[:8])
            if len(inst_freq_1) > 8:
                inst_outras_lista += f', ... (mais {len(inst_freq_1) - 8})'
            
            fig.text(0.12, 0.02, f'* Institui√ß√µes com 1 publica√ß√£o (total {len(inst_freq_1)}) incluem: {inst_outras_lista}',
                     fontsize=8, style='italic', wrap=True,
                     bbox=dict(boxstyle='round', facecolor=CORES_INTERMEDIARIAS[5], alpha=0.6))

        plt.tight_layout()
        plt.subplots_adjust(bottom=0.08)
        plt.savefig('graficos/04_todas_instituicoes.png', dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()
        print("‚úì Gr√°fico 4 gerado com sucesso")
    else:
        print("‚ö† Sem dados suficientes para gr√°fico de institui√ß√µes")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 4: {e}")

# GR√ÅFICO 5: Classifica√ß√£o por Foco em IA
print("\nüìä Gr√°fico 5/9: Classifica√ß√£o por Foco em IA")
try:
    fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')

    foco_order = ['IA - Foco Central', 'IA - Foco Relacionado', 'Outros Temas']
    foco_counts_ordered = foco_counts.reindex(foco_order, fill_value=0)

    colors_foco = [COR_IA_CENTRAL, COR_IA_RELACIONADA, COR_IA_OUTROS]
    bars = ax.bar(range(len(foco_counts_ordered)), foco_counts_ordered.values,
                  color=colors_foco, edgecolor='black', linewidth=1.5)

    ax.set_xticks(range(len(foco_counts_ordered)))
    ax.set_xticklabels(foco_counts_ordered.index, fontsize=11, rotation=15, ha='right')
    ax.set_title(f'Classifica√ß√£o por foco em Intelig√™ncia Artificial',
                 fontweight='bold', fontsize=13, pad=20)
    ax.set_ylabel('Quantidade', fontsize=12)
    ax.set_facecolor('white')
    ax.grid(True, alpha=0.3, axis='y', linestyle='--')

    for bar, v in zip(bars, foco_counts_ordered.values):
        pct = (v/len(df))*100
        ax.text(bar.get_x() + bar.get_width()/2, v + 1,
                f'{v}\n({pct:.1f}%)', ha='center', fontweight='bold', fontsize=10)

    plt.tight_layout()
    plt.savefig('graficos/05_foco_ia.png', dpi=300, bbox_inches='tight', facecolor='white')
    plt.show()
    print("‚úì Gr√°fico 5 gerado com sucesso")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 5: {e}")

# GR√ÅFICO 6: Evolu√ß√£o por N√≠vel
print("\nüìä Gr√°fico 6/9: Evolu√ß√£o Temporal por N√≠vel")
try:
    fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')

    colors_nivel = [COR_MESTRADO, COR_DOUTORADO]
    for i, nivel in enumerate(['Mestrado', 'Doutorado']):
        if nivel in nivel_ano.columns:
            ax.plot(nivel_ano.index, nivel_ano[nivel], marker='o',
                    label=nivel, linewidth=3, color=colors_nivel[i], markersize=10)

    ax.set_title(f'Evolu√ß√£o temporal por n√≠vel acad√™mico',
                 fontweight='bold', fontsize=13, pad=20)
    ax.set_xlabel('Ano', fontsize=12)
    ax.set_ylabel('Publica√ß√µes', fontsize=12)
    ax.legend(fontsize=11, loc='upper left')
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.set_facecolor('white')

    plt.tight_layout()
    plt.savefig('graficos/06_evolucao_nivel.png', dpi=300, bbox_inches='tight', facecolor='white')
    plt.show()
    print("‚úì Gr√°fico 6 gerado com sucesso")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 6: {e}")

# GR√ÅFICO 7: Distribui√ß√£o de P√°ginas
print("\nüìä Gr√°fico 7/9: Distribui√ß√£o do N√∫mero de P√°ginas")
try:
    paginas_limpo = df['num_paginas'].dropna()
    
    if len(paginas_limpo) > 0:
        fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')

        ax.hist(paginas_limpo, bins=25, color=COR_AZUL_PRINCIPAL,
                edgecolor='black', alpha=0.8, linewidth=1.5)

        media = paginas_limpo.mean()
        mediana = paginas_limpo.median()

        ax.set_title(f'Distribui√ß√£o do N√∫mero de P√°ginas',
                     fontweight='bold', fontsize=13, pad=20)
        ax.set_xlabel('N√∫mero de P√°ginas', fontsize=12)
        ax.set_ylabel('Frequ√™ncia', fontsize=12)
        ax.axvline(mediana, color=COR_MEDIANA, linestyle='--',
                   linewidth=3, label=f'Mediana: {mediana:.0f} p√°ginas')
        ax.legend(fontsize=11, loc='upper right')
        ax.set_facecolor('white')
        ax.grid(True, alpha=0.3, axis='y', linestyle='--')

        plt.tight_layout()
        plt.savefig('graficos/07_distribuicao_paginas.png', dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()
        print("‚úì Gr√°fico 7 gerado com sucesso")
    else:
        print("‚ö† Sem dados de p√°ginas dispon√≠veis")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 7: {e}")

# GR√ÅFICO 8: Top 10 Cidades
print("\nüìä Gr√°fico 8/9: Top 10 Cidades com Mais Publica√ß√µes")
try:
    top10_cidades = cidade_counts.head(10)
    
    if len(top10_cidades) > 0:
        fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')

        N = len(top10_cidades)
        cmap = cm.get_cmap('Greens_r', N + 5)
        cores_cidades = [cmap(i) for i in range(N)]

        bars = ax.barh(range(N), top10_cidades.values,
                       color=cores_cidades, 
                       edgecolor='black', linewidth=1.5)

        ax.set_yticks(range(N))
        ax.set_yticklabels(top10_cidades.index, fontsize=10)
        ax.invert_yaxis()

        ax.set_title(f'Top 10 Cidades com Mais Publica√ß√µes',
                     fontweight='bold', fontsize=13, pad=20)
        ax.set_xlabel('Quantidade de Publica√ß√µes', fontsize=11)
        ax.set_facecolor('white')
        ax.grid(True, alpha=0.3, axis='x', linestyle='--')

        for bar, v in zip(bars, top10_cidades.values):
            pct = (v/len(df))*100
            ax.text(v + 0.2, bar.get_y() + bar.get_height()/2,
                    f'{int(v)} ({pct:.1f}%)', va='center', fontsize=9, fontweight='bold')

        plt.tight_layout()
        plt.savefig('graficos/08_top10_cidades.png', dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()
        print("‚úì Gr√°fico 8 gerado com sucesso")
    else:
        print("‚ö† Sem dados de cidades dispon√≠veis")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 8: {e}")

# GR√ÅFICO 9: Evolu√ß√£o das Top 3 √Åreas
print("\nüìä Gr√°fico 9/9: Evolu√ß√£o temporal - Top 3 √°reas")
try:
    if len(area_counts) >= 3:
        fig, ax = plt.subplots(figsize=(12, 7), facecolor='white')

        top3_areas = area_counts.head(3).index
        colors_top3 = CORES_TOP3
        for i, area in enumerate(top3_areas):
            evolucao = df[df['area_normalizada'] == area].groupby('ano_defesa').size()
            if len(evolucao) > 0:
                ax.plot(evolucao.index, evolucao.values, marker='o', label=area,
                        linewidth=3, color=colors_top3[i], markersize=10)

        ax.set_title(f'Evolu√ß√£o Temporal - Top 3 √Åreas tem√°ticas',
                     fontweight='bold', fontsize=13, pad=20)
        ax.set_xlabel('Ano', fontsize=12)
        ax.set_ylabel('Publica√ß√µes', fontsize=12)
        ax.legend(fontsize=11, loc='upper left')
        ax.grid(True, alpha=0.3, linestyle='--')
        ax.set_facecolor('white')

        plt.tight_layout()
        plt.savefig('graficos/09_evolucao_top3_areas.png', dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()
        print("‚úì Gr√°fico 9 gerado com sucesso")
    else:
        print("‚ö† Sem dados suficientes para top 3 √°reas")
except Exception as e:
    print(f"‚ùå Erro ao gerar gr√°fico 9: {e}")

print("\n‚úÖ Gera√ß√£o de gr√°ficos conclu√≠da")

# =============================================================================
# 12. EXPORTAR RESULTADOS
# =============================================================================
print("\n" + "="*80)
print("Exportando resultados detalhados...")
print("="*80)

try:
    output_excel = 'resultados_detalhados_teses_ia.xlsx'

    with pd.ExcelWriter(output_excel, engine='openpyxl') as writer:
        # Resumo Geral
        resumo = pd.DataFrame({
            'M√©trica': [
                'Total de Publica√ß√µes',
                'Per√≠odo Analisado',
                'Mestrados',
                'Doutorados',
                'IA - Foco Central',
                'IA - Foco Relacionado',
                'Outros Temas',
                'N√∫mero de √Åreas',
                '√Åreas com 2+ publica√ß√µes',
                '√Åreas com 1 publica√ß√£o',
                'N√∫mero de Institui√ß√µes',
                'Institui√ß√µes com 2+ publica√ß√µes',
                'Institui√ß√µes com 1 publica√ß√£o',
                'Crescimento (%)',
                'Concentra√ß√£o √öltimos 3 anos (%)'
            ],
            'Valor': [
                len(df),
                f"{df['ano_defesa'].min()} - {df['ano_defesa'].max()}",
                nivel_counts.get('Mestrado', 0),
                nivel_counts.get('Doutorado', 0),
                foco_counts.get('IA - Foco Central', 0),
                foco_counts.get('IA - Foco Relacionado', 0),
                foco_counts.get('Outros Temas', 0),
                len(area_counts),
                len(areas_freq_maior_1),
                len(areas_freq_1),
                len(inst_counts),
                len(inst_freq_maior_1),
                len(inst_freq_1),
                f"{crescimento:.0f}%",
                f"{anos_recentes/len(df)*100:.1f}%"
            ]
        })
        resumo.to_excel(writer, sheet_name='Resumo Geral', index=False)
        
        # Outras planilhas
        pub_por_ano.to_excel(writer, sheet_name='Publica√ß√µes por Ano', index=False)
        area_counts.to_frame('Quantidade').to_excel(writer, sheet_name='Todas as √Åreas')
        inst_counts.to_frame('Quantidade').to_excel(writer, sheet_name='Todas as Institui√ß√µes')
        foco_counts.to_frame('Quantidade').to_excel(writer, sheet_name='Foco em IA')
        
        if len(areas_freq_1) > 0:
            areas_freq_1.to_frame('Quantidade').to_excel(writer, sheet_name='√Åreas com 1 pub')
        
        if len(inst_freq_1) > 0:
            inst_freq_1.to_frame('Quantidade').to_excel(writer, sheet_name='Institui√ß√µes com 1 pub')
        
        if top_termos:
            termos_df = pd.DataFrame(top_termos, columns=['Termo', 'Frequ√™ncia'])
            termos_df.to_excel(writer, sheet_name='Top Termos', index=False)
        
        df.to_excel(writer, sheet_name='Dataset Completo', index=False)

    print(f"‚úì Resultados salvos: {output_excel}")
except Exception as e:
    print(f"‚ùå Erro ao exportar resultados: {e}")

# =============================================================================
# 13. RELAT√ìRIO FINAL
# =============================================================================
print("\n" + "="*80)
print("RELAT√ìRIO FINAL - INSIGHTS PRINCIPAIS")
print("="*80)

top3_areas_str = "\n     ".join([f"{i+1}. {area}" for i, area in enumerate(area_counts.head(3).index)])
top3_inst_str = "\n     ".join([f"{i+1}. {inst}" for i, inst in enumerate(inst_counts.head(3).index)])

print(f"""
üìä RESUMO EXECUTIVO:

1. VOLUME E CRESCIMENTO:
   ‚Ä¢ Total de {len(df)} teses/disserta√ß√µes analisadas
   ‚Ä¢ Per√≠odo: {df['ano_defesa'].min()} a {df['ano_defesa'].max()}
   ‚Ä¢ Mestrados: {nivel_counts.get('Mestrado', 0)} ({nivel_counts.get('Mestrado', 0)/len(df)*100:.1f}%)
   ‚Ä¢ Doutorados: {nivel_counts.get('Doutorado', 0)} ({nivel_counts.get('Doutorado', 0)/len(df)*100:.1f}%)

2. FOCO EM INTELIG√äNCIA ARTIFICIAL:
   ‚Ä¢ IA como foco central: {foco_counts.get('IA - Foco Central', 0)} ({foco_counts.get('IA - Foco Central', 0)/len(df)*100:.1f}%)
   ‚Ä¢ IA como tema relacionado: {foco_counts.get('IA - Foco Relacionado', 0)} ({foco_counts.get('IA - Foco Relacionado', 0)/len(df)*100:.1f}%)

3. PRINCIPAIS √ÅREAS:
   ‚Ä¢ Top 3 √°reas:
     {top3_areas_str}

4. PRINCIPAIS INSTITUI√á√ïES:
   ‚Ä¢ Top 3 institui√ß√µes:
     {top3_inst_str}
""")

print("="*80)
print("‚úÖ AN√ÅLISE CONCLU√çDA COM SUCESSO!")
print("="*80)
print(f"\nArquivos gerados:")
print(f"  ‚Ä¢ Gr√°ficos na pasta 'graficos/'")
print(f"  ‚Ä¢ resultados_detalhados_teses_ia.xlsx")
print("\n" + "="*80)
